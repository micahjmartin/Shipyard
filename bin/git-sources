#!/usr/bin/env python3

import os
import sys
import requests
import shutil
import tempfile
import subprocess
import re

from shipyard import Version

def select_format(url: str) -> (str, str):
    for e in shutil.get_unpack_formats():
        for ext in e[1]:
            if url.endswith(ext):
                return e[0], ext
    return

def commit(dest, msg, version=None):
    r = subprocess.run(f'git add -Av', shell=True, cwd=dest, capture_output=True, encoding="utf-8")
    if r.returncode != 0:
        raise ValueError("git-add: "+r.stderr+r.stdout)
    r = subprocess.run(f'git commit -m "{msg}"', shell=True, cwd=dest, capture_output=True, encoding="utf-8")
    if r.returncode != 0:
        raise ValueError("git-commit: "+r.stderr+r.stdout)
    if version:
        r = subprocess.run(['git', "tag", "-a", version, "-m", msg], cwd=dest, capture_output=True, encoding="utf-8")
        if r.returncode != 0:
            raise ValueError("git-tag: "+r.stderr+r.stdout)

def get_version(fname: str) -> Version:
    """Get the version from url. We might need a better way to handle this if
    we encounter source that doesnt have the version in the URL"""
    match = re.match(r"[^\d]*(.*)", fname)
    if not match:
        # TODO: Get the version other ways?
        raise ValueError(f"version could not be determined from '{fname}'")
    return match.group(1)

def download_version(url: str, dest: str):
    """A new release does a few things.
    1. delete all files that dont start with .git
    2. downloads and extract contents into the git
    3. Commit the stuff, tag it
    """

    # Check if we have unstaged changes, if so, add them to a commit
    r = subprocess.run("git diff", cwd=dest, shell=True, capture_output=True)
    if len(r.stdout.splitlines()) > 0:
        print(f"[!] Unstaged changes exist in {dest}. Refusing to delete")
        print(r.stdout)
        exit(1)

    print(f"[*] Deleting all files in repository")
    for f in os.listdir(dest):
        if not f.startswith(".git"):
            f = os.path.join(dest, f)
            if os.path.isfile(f):
                os.remove(f)
            elif os.path.isdir(f):
                shutil.rmtree(f)
    
    print(f"[*] Downloading {url}")

    _, version = os.path.split(url)
    with tempfile.NamedTemporaryFile() as of:
        res = requests.get(url)
        if res.status_code < 200 or res.status_code >= 300:
            print(f"[!] Bad result {res.status_code} {res.reason}")
            print(res.content)
            raise ValueError(f"error downloading '{url}': {res.status_code}")
        with open(of.name, "wb") as f:
            f.write(res.content)
        # Unzip the contents into the directory
        fmt, ext = select_format(url)
        version = version[:-len(ext)]
        version = get_version(version)
        if not fmt:
            raise ValueError("Could not detect file format as determined by shutil")
        print(f"[*] Extracting files with {fmt} extractor")

        # Determine if all the files are stored in a sub-directory, if they are
        # move them out of the sub-dir
        with tempfile.TemporaryDirectory() as td:
            shutil.unpack_archive(of.name, td, fmt)
        
            src = td
            # Check if there is just a folder inside
            subs = os.listdir(td)
            if len(subs) == 1:
                src = os.path.join(src, subs[0])

            print(f"[*] Copying extracted files to {dest}")
            shutil.copytree(src, dest, dirs_exist_ok=True)
    
    # Make a commit here
    print(f"[*] Commiting files and tagging with version '{version}'")
    commit(dest, url, version)
    return

def init(dest):
    if not os.path.isdir(dest):
        os.makedirs(dest, exist_ok=True)
    subprocess.run("git init", shell=True, cwd=dest)

if __name__ == '__main__':
    init(sys.argv[2])
    download_version(sys.argv[1], sys.argv[2])